<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Overview</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h2>Overview</h2>

<p>MDTS provides the necessary infrastructure to take raw bam files of targeted sequencing trios to produce de novo deletion calls of high sensitivity and low false positives. Our method benefits tremendously from pooling information from across many trios to determine regions of interest, normalize read-depth, and to filter candidate deletion signals.</p>

<p>MDTS is broken down into the following major steps:</p>

<ol>
<li>Calculating the MDTS bins</li>
<li>Determinig the read-depth of the bins for each sample</li>
<li>Normalizing the read-depth</li>
<li>Creating the Minimum Distance for each trio</li>
<li>Call de novo deletions and filter</li>
</ol>

<h2>Raw Data</h2>

<p>The raw example sequencing data used in this vignette can be obtained from the github repo <code>jmf47/MDTSdata</code>. It includes:</p>

<ol>
<li>15 simulated bam files (5 trios) from the software <code>capsim</code>

<ul>
<li>Sequencing read length of 100bp </li>
<li>1 true de novo deletion at X in family F3</li>
<li>1 simulated CNP region where:</li>
<li><em>5/15 individuals have 2 copies (2/5 probands)</em></li>
<li><em>5/15 individuals have 1 copy (2/5 probands)</em></li>
<li><em>5/15 inviduals have 0 copies (1/5 probands)</em></li>
<li><em>50/50 Mendelian inheritance of allels in trios</em></li>
</ul></li>
<li>A pedigree file 

<ul>
<li>Records the trio kinships </li>
<li>Records the file paths to the raw bam files of each sample</li>
</ul></li>
</ol>

<pre><code>##      subj_id family_id father_id mother_id gender        bam_path
## 3       F1_1        F1      F1_2      F1_3      1 F1_1_sorted.bam
## 6       F1_3        F1         0         0      2 F1_3_sorted.bam
## 9       F1_2        F1         0         0      1 F1_2_sorted.bam
## 12      F2_1        F2      F2_2      F2_3      1 F2_1_sorted.bam
## 15      F2_3        F2         0         0      2 F2_3_sorted.bam
## 6.1     F2_2        F2         0         0      1 F2_2_sorted.bam
## 7       F3_1        F3      F3_2      F3_3      1 F3_1_sorted.bam
## 8       F3_3        F3         0         0      2 F3_3_sorted.bam
## 9.1     F3_2        F3         0         0      1 F3_2_sorted.bam
## 10      F4_1        F4      F4_2      F4_3      1 F4_1_sorted.bam
## 11      F4_3        F4         0         0      2 F4_3_sorted.bam
## 12.1    F4_2        F4         0         0      1 F4_2_sorted.bam
## 13      F5_1        F5      F5_2      F5_3      1 F5_1_sorted.bam
## 14      F5_3        F5         0         0      2 F5_3_sorted.bam
## 2       F5_2        F5         0         0      1 F5_2_sorted.bam
</code></pre>

<ol>
<li>A bw file that includes the 100mer mappability of the genome</li>
</ol>

<p>Slighly processed versions of the data is included with <code>MDTS</code>. To obtain the raw data use:</p>

<pre><code class="r">devtools::install_github(&#39;jmf47/MDTSdata&#39;)
</code></pre>

<h2>1. Calculating MDTS Bins</h2>

<p>One innovation of our method is that the bins to determine sequencing read depth is calculated based on the empirical capture. These bins can be significantly different from the standard practice of using probe design coordinates to create bins. Furthermore, our binning process allows the bins to be smaller in regions of high capture, and vice verse in low capture. This dynamic scaling of the bin size makes efficient use of varying depths of coverage - allowing us to call deletions with finer resolution in areas of higher coverage.</p>

<p>The general approach is first to examine the mapped coverage of a subset of the full dataset across the entire genome. Basepairs that are covered passed a certain threshold in at least one sample is selected as a proto-region. Proto-regions are subdvided into non-overlapping bins such that the median number of reads falling into each bin meets a specified level spcified by the <em>med</em> parameter. The choice of <em>med</em> is a tradeoff between sensitivity and false positives. A larger <em>med</em> decreases sensitivity and false positives. For our publication, we used <em>med=160</em>, and for this example we used <em>med=100</em>.</p>

<p>Information on GC content and mappability of the bins are also calculated at this stage. As a result, MDTS requires a BSgenome object that is consistent with the reference annotation the bam files were aligned to, as well as a mappability bigwig that contains mappability information in windows consistent with sequencing read length. In our example, we require <code>BSgenome.Hsapiesn.UCSC.hg19</code> and 100mer mappability.</p>

<p>This portion of the vignette requires using raw data from <code>MDTSData</code>. However the resulting bins are included in the <code>data</code> directory of MDTS.</p>

<pre><code class="r">library(MDTS); library(BSgenome.Hsapiens.UCSC.hg19)
# Using the raw data from MDTSData
setwd(system.file(&quot;data&quot;, package=&quot;MDTSData&quot;)) 

# Importing the pedigree file that includes information on where to locate the raw bam files
pD = pData(&quot;pData.ped&quot;)

# Information on the GC content and mappability to estimate GC and mappability for the MDTS bins
genome = BSgenome.Hsapiens.UCSC.hg19; map_file = &quot;chr22_100mer_map.bw&quot;

# This command now subsets 5 samples to determine MDTS bins
# pD is the phenotype matrix
# n is the number of samples to examine to calculate the bins
# rl is the sequencing read length
# min is the minimum read depth before a location is to be included in a proto region
# med is the minimum number of the median number of reads across the n samples in a bin.
bins = calcBins(pD, n=5, rl=100, med=100, min=5, genome, map_file)
</code></pre>

<h2>2. Calculating coverage of MDTS bins</h2>

<p>Given a set of dynamic MDTS bins, we can proceed to calculate the number of reads that fall into these bins for the entirety of our sample. We organize the number of reads as a matrix, where each column is a sample, and each row corresponds to a bin. This portion of the vignette is a continuation of the usage of the raw data from <code>MDTSdata</code> above. However the resulting <code>counts</code> matrix is also shipped as a <code>rda</code> in <code>MDTS</code>.</p>

<pre><code class="r"># pD is the phenotype matrix
# bins is the previously calculated MDTS bins
# rl is the sequencing read length
counts = calcCounts(pD, bins, rl=100)
</code></pre>

<p>The MDTS bins, raw counts, and pedigree files are included with <code>MDTS</code> and can be loaded as follows:</p>

<pre><code class="r">setwd(system.file(&quot;extdata&quot;, package=&quot;MDTS&quot;))
load(&#39;bins.RData&#39;)
load(&#39;counts.RData&#39;)
load(&#39;pD.RData&#39;)
</code></pre>

<p>The MDTS bins are</p>

<pre><code class="r">bins
</code></pre>

<pre><code>## GRanges object with 1654 ranges and 3 metadata columns:
##          seqnames               ranges strand | median_count
##             &lt;Rle&gt;            &lt;IRanges&gt;  &lt;Rle&gt; |    &lt;numeric&gt;
##      [1]    chr22 [50004903, 50006812]      * |       180.37
##      [2]    chr22 [50044645, 50045624]      * |       100.15
##      [3]    chr22 [50045625, 50046049]      * |       100.15
##      [4]    chr22 [50046050, 50046465]      * |       100.04
##      [5]    chr22 [50046466, 50046833]      * |       100.17
##      ...      ...                  ...    ... .          ...
##   [1650]    chr22 [51209086, 51209261]      * |       100.49
##   [1651]    chr22 [51209262, 51209409]      * |       100.56
##   [1652]    chr22 [51210121, 51210304]      * |       100.28
##   [1653]    chr22 [51210707, 51210835]      * |       100.01
##   [1654]    chr22 [51213617, 51213844]      * |        100.3
##                         GC       mappability
##                  &lt;numeric&gt;         &lt;numeric&gt;
##      [1]  0.37434554973822 0.988758726059142
##      [2] 0.461224489795918                 1
##      [3] 0.482352941176471                 1
##      [4] 0.459134615384615                 1
##      [5] 0.494565217391304 0.953351449423834
##      ...               ...               ...
##   [1650] 0.335227272727273 0.769886363636364
##   [1651] 0.439189189189189 0.888513513513513
##   [1652] 0.516304347826087 0.777173913043478
##   [1653] 0.465116279069767 0.856589147286822
##   [1654] 0.609649122807018 0.754385964912281
##   -------
##   seqinfo: 1 sequence from an unspecified genome; no seqlengths
</code></pre>

<p>The count matrix where each column is a sample and each row is a bin:</p>

<pre><code class="r">head(counts)
</code></pre>

<pre><code>##        F1_1   F1_3   F1_2   F2_1   F2_3   F2_2   F3_1   F3_3   F3_2   F4_1
## [1,] 190.15 155.14 213.33 227.96 156.58 180.37 212.26 195.62 132.87 166.57
## [2,] 100.15  91.83 109.40 101.43 122.23  90.42  96.66 155.46  94.87 102.48
## [3,] 102.23  89.00  82.16  87.30 100.15  65.89  85.24  82.48 101.68  88.46
## [4,] 100.68  88.84  96.84 110.35  97.74 109.02 111.00 100.04  89.40  82.17
## [5,] 103.85  75.92  80.84  78.85 117.51  98.52  67.77 100.17  98.84  79.99
## [6,]  97.29  94.67  85.68  72.51 104.83  81.41  76.75 109.91 100.14  97.36
##        F4_3   F4_2   F5_1   F5_3   F5_2
## [1,] 173.27 188.87 176.67 183.73 187.07
## [2,]  72.05 107.33 106.82  78.05  98.87
## [3,]  91.23  73.36  92.64 115.60  95.04
## [4,] 105.65  86.45 112.34  84.98  98.75
## [5,]  93.96  79.18 105.77  88.20  92.91
## [6,]  67.55  79.01 113.02 105.91  97.32
</code></pre>

<h2>3. Normalizing the read-depth</h2>

<p>After obtaining the raw read-depth matrix, MDTS calculates a vector M score matrix of the same organization - each row corresponds to a row and each column a sample. The M score is based on a log2 transformation, followed by median polish, and GC and mappability adjust via a loess smoother. The resulting M scores have critical values where (0, -1, &lt;-4) are generally consistent with 2, 1, and 0 copy numbers [barring Copy Number Polymorphisms].</p>

<pre><code class="r"># counts is the raw read depth of [MDTS bins x samples]
# bins is the previously calculated MDTS bins
mCounts = normalizeCounts(counts, bins)
</code></pre>

<pre><code>## [1] &quot;Log Transforming Counts&quot;
## [1] &quot;GC Adjust&quot;
## [1] &quot;Mappability Adjust&quot;
</code></pre>

<h2>4. Creating the Minimum Distance for each trio</h2>

<p>The second advantage of MDTS is the use of Minimum Distances for candidate de novo deletion identification. The assumption underlying the development of the Minimum Distance is that it is vastly more likely for a deletion to be inherited than de novo if the proband shares a deletion with one of the parents in the trio. Based on that assumption, the Minimum Distance is calculated per family - bin combination. For each bin, the Minimum Distance is smallest (in absolute terms) difference between the proband&#39;s M score and both parents&#39;. </p>

<p>For example, if the M scores are (-1, -1, 0) for a proband and the 2 parents respectively, a situation consistent with an inherited deletion in the proband from parent 1, the Minimum Distance of the 2 possible pairwise comparisons is 0. On the other hand, if the M scores are (-1, 0, 0) for the proband and the 2 parents, the Minimum Distance stands out at -1, and is consistent with a de novo deletion. </p>

<p>To calculate the Minimum Distance of the dataset, MDTS takes as input the M score matrix. The output matrix is organized where each row corresponds still to a bin, but each column now refers to a trio.</p>

<pre><code class="r"># mCounts is the normalized read depth of [MDTS bins x samples]
# bins is the previously calculated MDTS bins
# pD is the phenotype matrix
md = calcMD(mCounts, bins, pD)
</code></pre>

<h2>5. Call de novo deletions and filter</h2>

<p>Using the Minimum Distance matrix calculated above, MDTS uses the tried and true Circular Binary Segmentation method to infer deletion states. Inferred candidate de novo deletions are further filtered to remove likely false positive signals that arose out of regions of highly variable read-depth (generally indicative of sequence artifacts or polymorphic events).</p>

<pre><code class="r"># md is the Minimum Distance of [MDTS bins x trio]
# bins is the previously calculated MDTS bins
# mCounts is the normalized read depth of [MDTS bins x samples]
cbs = segmentMD(md, bins)
</code></pre>

<pre><code>## [1] &quot;Processing family number: 1&quot;
## [1] &quot;Processing family number: 2&quot;
## [1] &quot;Processing family number: 3&quot;
## [1] &quot;Processing family number: 4&quot;
## [1] &quot;Processing family number: 5&quot;
</code></pre>

<pre><code class="r">denovo = denovoDeletions(cbs, mCounts, bins)
</code></pre>

<pre><code>## [1] &quot;Selecting Candidate de Novo deletions&quot;
## [1] &quot;Calculating problematic bins&quot;
## [1] &quot;Filtering candidates by problematic bins&quot;
</code></pre>

<p>In our example, the final output is a single detected de novo deletion in family F3:</p>

<pre><code class="r">denovo
</code></pre>

<pre><code>## GRanges object with 1 range and 2 metadata columns:
##       seqnames               ranges strand |         m       famid
##          &lt;Rle&gt;            &lt;IRanges&gt;  &lt;Rle&gt; | &lt;numeric&gt; &lt;character&gt;
##   [1]    chr22 [50806919, 50811080]      * |   -0.9213        F3_1
##   -------
##   seqinfo: 1 sequence from an unspecified genome; no seqlengths
</code></pre>

<p>No signals were picked up from the CNP region or elsewhere.</p>

</body>

</html>
